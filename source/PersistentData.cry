import FileIO;

/*
data saved:
boolean -> intro_shown

boolean -> {map key}_completed
float -> {map_key}_longestjump (seconds)
float -> {map_key}_fastesttime (seconds)
int -> {map_key}_fewestjumps
int -> {map_key}_timesplayed

A map is considered unlocked if it is first in the manifest or its previous map is marked as _completed

*/

class PersistentData {
	
	static field INSTANCE = new PersistentData();
	
	field values = {};
	field folder = '.';
	field filename = 'pp_save_data.txt';
	
	constructor() {
		this.initialize(); // sets the save file or doesn't if it can't figure out the system.
	}
	
	function initialize() {
		if (!FileIO.UserData.Path.exists(this.filename)) return;
		data = FileIO.UserData.File.readText(this.filename);
		
		for (line : data.split('\n')) {
			line = line.trim();
			if (line.length > 0) {
				parts = line.split(':');
				if (parts.length >= 3) {
					t = parts[0].upper().trim();
					k = parts[1].trim();
					v = parts[2:].join(':').trim();
					if (t == 'I') {
						v = parseInt(v);
						if (v == null) k = null;
					} else if (t == 'F') {
						v = parseFloat(v);
						if (v == null) k = null;
					} else if (t == 'B') {
						v = v == '1';
					} else if (t == 'S') {
						// pass
					} else if (t == 'N') {
						v = null;
					} else {
						k = null;
					}
					if (k != null) {
						this.values[k] = v;
					}
				}
			}
		}
	}
	
	function save() {
		if (this.folder == null) return;
		output = [];
		for (key in this.values.keys()) {
			t = null;
			value = this.values[key];
			ktype = typeof(value);
			switch (ktype) {
				case Type.INTEGER: t = 'I'; break;
				case Type.STRING: t = 'S'; break;
				case Type.BOOLEAN: t = 'B'; value = value ? 1 : 0; break;
				case Type.FLOAT: t = 'F'; break;
				case Type.NULL: t = 'N'; value = '-'; break;
				default: Core.assert(false); break; // unusable type
			}
			output.add(t + ':' + key + ':' + value);
		}
		
		FileIO.UserData.File.writeText(this.filename, output.join('\n'));
	}
	
	function getBoolean(key, defaultValue = false):
		return this.values.get(key, def) == true;
	}
	
	function getFloat(key, defaultValue = 0.0) {
		output = this.values.get(key, defaultValue);
		if (typeof(output) == Type.FLOAT) return output;
		if (typeof(output) == Type.INTEGER) return output + 0.0;
		return defaultValue;
	}
	
	function getInteger(key, defaultValue = 0) {
		return this.getInt(key, defaultValue);
	}
	
	function getInt(key, defaultValue = 0) {
		output = this.values.get(key, defaultValue);
		if (typeof(output) == Type.INTEGER) return output;
		if (typeof(output) == Type.FLOAT) return floor(output);
		return defaultValue;
	}
	
	function getString(key, defaultValue = null) {
		return '' + this.values.get(key, defaultValue);
	}
	
	function hasValue(key) {
		return this.values.contains(key);
	}
	
	function setValue(key, value) {
		this.values[key] = value;
	}
}
